/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scss_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scss/app.scss */ \"./src/scss/app.scss\");\n/* harmony import */ var _demo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./demo.js */ \"./src/js/demo.js\");\n/* harmony import */ var _demo_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_demo_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _accordion_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./accordion.mjs */ \"./src/js/accordion.mjs\");\n/* harmony import */ var _navToggle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navToggle */ \"./src/js/navToggle.js\");\n/* harmony import */ var _navToggle__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_navToggle__WEBPACK_IMPORTED_MODULE_3__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n/* Your JS Code goes here */\n\n/* Demo JS */\n\n\n\n\nvar _iterator = _createForOfIteratorHelper(document.querySelectorAll(\".accordion\")),\n    _step;\n\ntry {\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    var el = _step.value;\n    new _accordion_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"](el);\n  }\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBOztBQUlBOztBQUNBO0FBRUE7OzJDQUNpQkMsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixZQUExQjs7OztFQUFqQixvREFBMEQ7SUFBQSxJQUEvQ0MsRUFBK0M7SUFBQSxJQUFJSCxzREFBSixDQUFjRyxFQUFkO0VBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGdlb3Rvb2xraXQvZ2VvdG9vbGtpdC8uL3NyYy9qcy9hcHAuanM/OTBlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3Njc3MvYXBwLnNjc3MnO1xyXG5cclxuLyogWW91ciBKUyBDb2RlIGdvZXMgaGVyZSAqL1xyXG5cclxuXHJcblxyXG4vKiBEZW1vIEpTICovXHJcbmltcG9ydCAnLi9kZW1vLmpzJztcclxuXHJcbmltcG9ydCBBY2NvcmRpb24gZnJvbSBcIi4vYWNjb3JkaW9uLm1qc1wiO1xyXG5mb3IgKGNvbnN0IGVsIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNjb3JkaW9uXCIpKSBuZXcgQWNjb3JkaW9uKGVsKTtcclxuaW1wb3J0ICcuL25hdlRvZ2dsZSc7Il0sIm5hbWVzIjpbIkFjY29yZGlvbiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/app.js\n");

/***/ }),

/***/ "./src/js/demo.js":
/*!************************!*\
  !*** ./src/js/demo.js ***!
  \************************/
/***/ (() => {

eval("var demo = function demo() {\n  return 'Webpack Boilerplate v5.12.0 - SASS/PostCSS, ES6/7, browser sync, source code listing and more.';\n}; // eslint-disable-next-line no-console\n\n\nconsole.log(demo());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZGVtby5qcy5qcyIsIm5hbWVzIjpbImRlbW8iLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ2VvdG9vbGtpdC9nZW90b29sa2l0Ly4vc3JjL2pzL2RlbW8uanM/YzM0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZW1vID0gKCkgPT4gJ1dlYnBhY2sgQm9pbGVycGxhdGUgdjUuMTIuMCAtIFNBU1MvUG9zdENTUywgRVM2LzcsIGJyb3dzZXIgc3luYywgc291cmNlIGNvZGUgbGlzdGluZyBhbmQgbW9yZS4nO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuY29uc29sZS5sb2coZGVtbygpKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFNQSxJQUFJLEdBQUcsU0FBUEEsSUFBTztFQUFBLE9BQU0sZ0dBQU47QUFBQSxDQUFiLEMsQ0FFQTs7O0FBQ0FDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZRixJQUFJLEVBQWhCIn0=\n//# sourceURL=webpack-internal:///./src/js/demo.js\n");

/***/ }),

/***/ "./src/js/navToggle.js":
/*!*****************************!*\
  !*** ./src/js/navToggle.js ***!
  \*****************************/
/***/ (() => {

eval("document.querySelector('#globalHeader-collapse-button').addEventListener('click', function (e) {\n  var select = document.querySelector('.accordion-menu-holder');\n  select.classList.toggle('close');\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbmF2VG9nZ2xlLmpzLmpzIiwibmFtZXMiOlsiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzZWxlY3QiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL0BnZW90b29sa2l0L2dlb3Rvb2xraXQvLi9zcmMvanMvbmF2VG9nZ2xlLmpzPzIyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dsb2JhbEhlYWRlci1jb2xsYXBzZS1idXR0b24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICBsZXQgc2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFjY29yZGlvbi1tZW51LWhvbGRlcicpO1xyXG5cclxuXHJcbiAgICBzZWxlY3QuY2xhc3NMaXN0LnRvZ2dsZSgnY2xvc2UnKTtcclxuXHJcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUFBLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QiwrQkFBdkIsRUFBd0RDLGdCQUF4RCxDQUF5RSxPQUF6RSxFQUFrRixVQUFTQyxDQUFULEVBQVk7RUFFMUYsSUFBSUMsTUFBTSxHQUFHSixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsd0JBQXZCLENBQWI7RUFHQUcsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxNQUFqQixDQUF3QixPQUF4QjtBQUVILENBUEQifQ==\n//# sourceURL=webpack-internal:///./src/js/navToggle.js\n");

/***/ }),

/***/ "./src/scss/app.scss":
/*!***************************!*\
  !*** ./src/scss/app.scss ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2Nzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ2VvdG9vbGtpdC9nZW90b29sa2l0Ly4vc3JjL3Njc3MvYXBwLnNjc3M/NjI5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scss/app.scss\n");

/***/ }),

/***/ "./src/js/accordion.mjs":
/*!******************************!*\
  !*** ./src/js/accordion.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Accordion)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/js/helpers.mjs\");\n/* harmony import */ var _fold_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fold.mjs */ \"./src/js/fold.mjs\");\n\r\n\r\n\r\nconst accordions = [];\r\nlet activeAccordions = 0;\r\nlet lastResizeRate;\r\n\r\n\r\n/**\r\n * Represents a column of collapsible content regions.\r\n * @class\r\n */\r\nclass Accordion {\r\n\r\n    /**\r\n     * Instantiate a new Accordion instance.\r\n     *\r\n     * @param {HTMLElement} el                    - Container wrapped around each immediate fold\r\n     * @param {Object}      options               - Optional hash of settings\r\n     * @param {String}      options.openClass     - CSS class controlling each fold's \"open\" state\r\n     * @param {String}      options.closeClass    - CSS class used to mark a fold as closed\r\n     * @param {String}      options.edgeClass     - CSS class toggled based on whether the bottom-edge is visible\r\n     * @param {String}      options.snapClass     - CSS class for disabling transitions between window resizes\r\n     * @param {String}      options.enabledClass  - CSS class marking an accordion as enabled\r\n     * @param {String}      options.disabledClass - CSS class marking an accordion as disabled\r\n     * @param {Boolean}     options.disabled      - Whether to disable the accordion on creation\r\n     * @param {Boolean}     options.modal         - Whether to close the current fold when opening another\r\n     * @param {Boolean}     options.noAria        - Disable the addition and management of ARIA attributes\r\n     * @param {Boolean}     options.noKeys        - Disable keyboard navigation\r\n     * @param {Boolean}     options.noTransforms  - Disable CSS transforms; positioning will be used instead\r\n     * @param {Number}      options.heightOffset  - Distance to offset each fold by\r\n     * @param {Boolean}     options.useBorders    - Consider borders when calculating fold heights\r\n     * @param {Function}    options.onToggle      - Callback executed when opening or closing a fold\r\n     * @constructor\r\n     */\r\n    constructor(el, options) {\r\n        this.index = accordions.push(this) - 1;\r\n\r\n        // Parse options\r\n        options = options || {};\r\n        this.openClass = options.openClass || \"open\";\r\n        this.closeClass = options.closeClass || \"closed\";\r\n        this.edgeClass = (undefined === options.edgeClass ? \"edge-visible\" : options.edgeClass);\r\n        this.snapClass = (undefined === options.snapClass ? \"snap\" : options.snapClass);\r\n        this.enabledClass = (undefined === options.enabledClass ? \"accordion\" : options.enabledClass);\r\n        this.disabledClass = options.disabledClass;\r\n        this.modal = !!options.modal;\r\n        this.noAria = !!options.noAria;\r\n        this.noKeys = !!options.noKeys;\r\n        this.noTransforms = !!options.noTransforms;\r\n        this.heightOffset = +options.heightOffset || 0;\r\n        this.useBorders = undefined === options.useBorders ? \"auto\" : options.useBorders;\r\n        this.onToggle = options.onToggle;\r\n\r\n\r\n        // Create a fold for each immediate descendant of the Accordion's container\r\n        let folds = [];\r\n        for (let i of Array.from(el.children)) {\r\n            let fold = new _fold_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, i);\r\n            folds.push(fold);\r\n\r\n            // Connect the fold to its previous sibling, if it's not the first to be added\r\n            let prev = folds[folds.length - 2];\r\n            if (prev) {\r\n                prev.nextFold = fold;\r\n                fold.previousFold = prev;\r\n            }\r\n        }\r\n\r\n\r\n        el.accordion = this.index;\r\n        this.noAria || el.setAttribute(\"role\", \"tablist\");\r\n        this.el = el;\r\n        this.folds = folds;\r\n\r\n        // Add .enabledClass early - it might affect the heights of each fold\r\n        if (!options.disabled && this.enabledClass)\r\n            el.classList.add(this.enabledClass);\r\n\r\n        this.update();\r\n\r\n\r\n        // Find out if this accordion's nested inside another\r\n        let next = el;\r\n        while ((next = next.parentNode) && 1 === next.nodeType) {\r\n            let fold = Accordion.getFold(next);\r\n            if (fold) {\r\n                let accordion = fold.accordion;\r\n                this.parent = accordion;\r\n                this.parentFold = fold;\r\n                this.edgeClass && el.classList.remove(this.edgeClass);\r\n                (accordion.childAccordions = accordion.childAccordions || []).push(this);\r\n                (fold.childAccordions = fold.childAccordions || []).push(this);\r\n\r\n                // Adjust the height of the containing fold's element\r\n                if (fold.open) {\r\n                    let scrollHeight = fold.el.scrollHeight;\r\n                    let distance = (fold.headingHeight + fold.content.scrollHeight) - scrollHeight || (scrollHeight - fold.el.clientHeight);\r\n                    accordion.updateFold(fold, distance);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n        this.edgeClass && this.el.addEventListener(_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.transitionEnd, this.onTransitionEnd = e => {\r\n            if (!this.parent && e.target === el && \"height\" === e.propertyName && el.getBoundingClientRect().bottom > window.innerHeight)\r\n                el.classList.remove(this.edgeClass);\r\n        });\r\n\r\n        this.disabled = !!options.disabled;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get or set the accordion enclosing this one.\r\n     *\r\n     * @property\r\n     * @type {Accordion}\r\n     */\r\n    set parent(input) { this._parent = input; }\r\n    get parent() {\r\n        let result = this._parent;\r\n        if (!result) return null;\r\n\r\n        // Search for the first ancestor that *isn't* disabled\r\n        while (result) {\r\n            if (!result.disabled) return result;\r\n            result = result.parent;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get or set the fold of the accordion enclosing this one.\r\n     *\r\n     * @property\r\n     * @type {Fold}\r\n     */\r\n    set parentFold(input) { this._parentFold = input; }\r\n    get parentFold() {\r\n        let fold = this._parentFold;\r\n        if (!fold) return null;\r\n\r\n        let accordion = fold.accordion;\r\n\r\n        // Search for the first ancestor that *isn't* disabled\r\n        while (fold && accordion) {\r\n            if (!accordion.disabled) return fold;\r\n            if (accordion = accordion.parent)\r\n                fold = accordion.parentFold;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Whether the accordion's been deactivated.\r\n     *\r\n     * @property\r\n     * @type {Boolean}\r\n     */\r\n    get disabled() { return this._disabled; }\r\n    set disabled(input) {\r\n        if ((input = !!input) !== this._disabled) {\r\n            const el = this.el;\r\n            const style = el.style;\r\n            const classes = el.classList;\r\n\r\n            this.enabledClass && (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setToken)(classes, this.enabledClass, !input);\r\n            this.disabledClass && (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setToken)(classes, this.disabledClass, input);\r\n\r\n\r\n            // Deactivating\r\n            if (this._disabled = input) {\r\n                style.height = null;\r\n                this.snapClass && classes.remove(this.snapClass);\r\n                if (this.edgeClass) {\r\n                    el.removeEventListener(_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.transitionEnd, this.onTransitionEnd);\r\n                    classes.remove(this.edgeClass);\r\n                }\r\n\r\n                for (let i of this.folds)\r\n                    i.disabled = true;\r\n\r\n                this.noAria || el.removeAttribute(\"role\");\r\n                --activeAccordions;\r\n            }\r\n\r\n\r\n            // Reactivating\r\n            else {\r\n                for (let i of this.folds)\r\n                    i.disabled = false;\r\n\r\n                this.noAria || el.setAttribute(\"role\", \"tablist\");\r\n                ++activeAccordions;\r\n                this.update();\r\n            }\r\n\r\n\r\n\r\n            // If there're no more active accordions, disable the onResize handler\r\n            if (activeAccordions <= 0) {\r\n                activeAccordions = 0;\r\n                Accordion.setResizeRate(false);\r\n            }\r\n\r\n            // Otherwise, reactivate the onResize handler, assuming it was previously active\r\n            else if (lastResizeRate)\r\n                Accordion.setResizeRate(lastResizeRate);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Height of the accordion's container element.\r\n     *\r\n     * @property\r\n     * @type {Number}\r\n     */\r\n    get height() { return this._height; }\r\n    set height(input) {\r\n        if (input && (input = +input) !== this._height) {\r\n            this.el.style.height = input + \"px\";\r\n            this._height = input;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Internal method to check if an accordion's bottom-edge is visible to the user (or about to be).\r\n     *\r\n     * @param {Number} offset\r\n     * @private\r\n     */\r\n    edgeCheck(offset) {\r\n        let edgeClass = this.edgeClass;\r\n        if (edgeClass) {\r\n            let box = this.el.getBoundingClientRect();\r\n            let windowEdge = window.innerHeight;\r\n            let classes = this.el.classList;\r\n\r\n            // If the bottom-edge is visible (or about to be), enable height animation\r\n            if (box.bottom + (offset || 0) < windowEdge)\r\n                classes.add(edgeClass);\r\n\r\n            // If the bottom-edge isn't visible anyway, disable height animation immediately\r\n            else if (box.bottom > windowEdge)\r\n                classes.remove(edgeClass);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Update the vertical ordinate of each sibling for a particular fold.\r\n     *\r\n     * @param {Fold} fold\r\n     * @param {Number} offset - Pixel distance to adjust by\r\n     */\r\n    updateFold(fold, offset) {\r\n        let next = fold;\r\n        let parentFold = this.parentFold;\r\n\r\n        while (next = next.nextFold)\r\n            next.y += offset;\r\n        parentFold || this.edgeCheck(offset);\r\n        fold.height += offset;\r\n        this.height += offset;\r\n\r\n        parentFold && parentFold.open && this.parent.updateFold(parentFold, offset);\r\n    }\r\n\r\n\r\n    /**\r\n     * Update the height of each fold to fit its content.\r\n     */\r\n    update() {\r\n        let y = 0;\r\n        let height = 0;\r\n        for (let i of this.folds) {\r\n            i.y = y;\r\n            i.fit();\r\n            y += i.height;\r\n            height += i.height;\r\n        }\r\n\r\n        let parentFold = this.parentFold;\r\n        let diff = height - this._height;\r\n        parentFold\r\n            ?\r\n            (parentFold.open && this.parent.updateFold(parentFold, diff)) :\r\n            this.edgeCheck(diff);\r\n\r\n        this.height = height;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Recalculate the boundaries of an Accordion and its descendants.\r\n     *\r\n     * This method should only be called if the width of a container changes,\r\n     * or a fold's contents have resized unexpectedly (such as when images load).\r\n     *\r\n     * @param {Boolean} allowSnap - Snap folds instantly into place without transitioning\r\n     */\r\n    refresh(allowSnap) {\r\n        let snap = allowSnap ? this.snapClass : false;\r\n        snap && this.el.classList.add(snap);\r\n\r\n        this.update();\r\n        if (this.childAccordions)\r\n            this.childAccordions.forEach(a => a.parentFold.open ?\r\n                a.refresh(allowSnap) :\r\n                (a.parentFold.needsRefresh = true));\r\n\r\n        snap && setTimeout(() => this.el.classList.remove(snap), 20);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Whether one of the Accordion's folds has been resized incorrectly.\r\n     *\r\n     * @type {Boolean}\r\n     * @readonly\r\n     * @property\r\n     */\r\n    get wrongSize() {\r\n        for (let i of this.folds)\r\n            if (i.wrongSize) return true;\r\n        if (this.childAccordions)\r\n            for (let i of this.childAccordions)\r\n                if (i.wrongSize) return true;\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Return the top-level ancestor this accordion's nested inside.\r\n     *\r\n     * @type {Accordion}\r\n     * @readonly\r\n     * @property\r\n     */\r\n    get root() {\r\n        let result = this;\r\n        while (result) {\r\n            if (!result.parent) return result;\r\n            result = result.parent;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Alter the rate at which screen-resize events update accordion widths.\r\n     *\r\n     * @param {Number} delay - Rate expressed in milliseconds\r\n     */\r\n    static setResizeRate(delay) {\r\n        let fn = function() {\r\n            for (let i of accordions)\r\n                i.parent || i.disabled || i.refresh(true);\r\n        };\r\n\r\n        window.removeEventListener(\"resize\", this.onResize);\r\n\r\n        // Make sure we weren't passed an explicit value of FALSE, or a negative value\r\n        if (false !== delay && (delay = +delay || 0) >= 0) {\r\n            this.onResize = delay ? (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce)(fn, delay) : fn;\r\n            window.addEventListener(\"resize\", this.onResize);\r\n            if (delay) lastResizeRate = delay;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Return the closest (most deeply-nested) accordion enclosing an element.\r\n     *\r\n     * @param {Node} node\r\n     * @return {Accordion}\r\n     */\r\n    static getAccordion(node) {\r\n        while (node) {\r\n            if (\"accordion\" in node)\r\n                return accordions[node.accordion];\r\n\r\n            node = node.parentNode;\r\n            if (!node || node.nodeType !== 1) return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Return the closest (most deeply-nested) fold enclosing an element.\r\n     *\r\n     * @param {Node} node\r\n     * @return {Fold}\r\n     */\r\n    static getFold(node) {\r\n        while (node) {\r\n            if (\"accordionFold\" in node)\r\n                return _fold_mjs__WEBPACK_IMPORTED_MODULE_1__.folds[node.accordionFold];\r\n\r\n            node = node.parentNode;\r\n            if (!node || node.nodeType !== 1) return null;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nAccordion.setResizeRate(25);\r\nwindow.Accordion = Accordion;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BnZW90b29sa2l0L2dlb3Rvb2xraXQvLi9zcmMvanMvYWNjb3JkaW9uLm1qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zaXRpb25FbmQsIHNldFRva2VuLCBkZWJvdW5jZSB9IGZyb20gXCIuL2hlbHBlcnMubWpzXCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgRm9sZCwgZm9sZHMgfSBmcm9tIFwiLi9mb2xkLm1qc1wiO1xyXG5cclxuY29uc3QgYWNjb3JkaW9ucyA9IFtdO1xyXG5sZXQgYWN0aXZlQWNjb3JkaW9ucyA9IDA7XHJcbmxldCBsYXN0UmVzaXplUmF0ZTtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNvbHVtbiBvZiBjb2xsYXBzaWJsZSBjb250ZW50IHJlZ2lvbnMuXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3JkaW9uIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IEFjY29yZGlvbiBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICAgICAgLSBDb250YWluZXIgd3JhcHBlZCBhcm91bmQgZWFjaCBpbW1lZGlhdGUgZm9sZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgIC0gT3B0aW9uYWwgaGFzaCBvZiBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgb3B0aW9ucy5vcGVuQ2xhc3MgICAgIC0gQ1NTIGNsYXNzIGNvbnRyb2xsaW5nIGVhY2ggZm9sZCdzIFwib3BlblwiIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBvcHRpb25zLmNsb3NlQ2xhc3MgICAgLSBDU1MgY2xhc3MgdXNlZCB0byBtYXJrIGEgZm9sZCBhcyBjbG9zZWRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIG9wdGlvbnMuZWRnZUNsYXNzICAgICAtIENTUyBjbGFzcyB0b2dnbGVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGJvdHRvbS1lZGdlIGlzIHZpc2libGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIG9wdGlvbnMuc25hcENsYXNzICAgICAtIENTUyBjbGFzcyBmb3IgZGlzYWJsaW5nIHRyYW5zaXRpb25zIGJldHdlZW4gd2luZG93IHJlc2l6ZXNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIG9wdGlvbnMuZW5hYmxlZENsYXNzICAtIENTUyBjbGFzcyBtYXJraW5nIGFuIGFjY29yZGlvbiBhcyBlbmFibGVkXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBvcHRpb25zLmRpc2FibGVkQ2xhc3MgLSBDU1MgY2xhc3MgbWFya2luZyBhbiBhY2NvcmRpb24gYXMgZGlzYWJsZWRcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIG9wdGlvbnMuZGlzYWJsZWQgICAgICAtIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgYWNjb3JkaW9uIG9uIGNyZWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBvcHRpb25zLm1vZGFsICAgICAgICAgLSBXaGV0aGVyIHRvIGNsb3NlIHRoZSBjdXJyZW50IGZvbGQgd2hlbiBvcGVuaW5nIGFub3RoZXJcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIG9wdGlvbnMubm9BcmlhICAgICAgICAtIERpc2FibGUgdGhlIGFkZGl0aW9uIGFuZCBtYW5hZ2VtZW50IG9mIEFSSUEgYXR0cmlidXRlc1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgb3B0aW9ucy5ub0tleXMgICAgICAgIC0gRGlzYWJsZSBrZXlib2FyZCBuYXZpZ2F0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBvcHRpb25zLm5vVHJhbnNmb3JtcyAgLSBEaXNhYmxlIENTUyB0cmFuc2Zvcm1zOyBwb3NpdGlvbmluZyB3aWxsIGJlIHVzZWQgaW5zdGVhZFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgb3B0aW9ucy5oZWlnaHRPZmZzZXQgIC0gRGlzdGFuY2UgdG8gb2Zmc2V0IGVhY2ggZm9sZCBieVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgb3B0aW9ucy51c2VCb3JkZXJzICAgIC0gQ29uc2lkZXIgYm9yZGVycyB3aGVuIGNhbGN1bGF0aW5nIGZvbGQgaGVpZ2h0c1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgb3B0aW9ucy5vblRvZ2dsZSAgICAgIC0gQ2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBvcGVuaW5nIG9yIGNsb3NpbmcgYSBmb2xkXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gYWNjb3JkaW9ucy5wdXNoKHRoaXMpIC0gMTtcclxuXHJcbiAgICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub3BlbkNsYXNzID0gb3B0aW9ucy5vcGVuQ2xhc3MgfHwgXCJvcGVuXCI7XHJcbiAgICAgICAgdGhpcy5jbG9zZUNsYXNzID0gb3B0aW9ucy5jbG9zZUNsYXNzIHx8IFwiY2xvc2VkXCI7XHJcbiAgICAgICAgdGhpcy5lZGdlQ2xhc3MgPSAodW5kZWZpbmVkID09PSBvcHRpb25zLmVkZ2VDbGFzcyA/IFwiZWRnZS12aXNpYmxlXCIgOiBvcHRpb25zLmVkZ2VDbGFzcyk7XHJcbiAgICAgICAgdGhpcy5zbmFwQ2xhc3MgPSAodW5kZWZpbmVkID09PSBvcHRpb25zLnNuYXBDbGFzcyA/IFwic25hcFwiIDogb3B0aW9ucy5zbmFwQ2xhc3MpO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZENsYXNzID0gKHVuZGVmaW5lZCA9PT0gb3B0aW9ucy5lbmFibGVkQ2xhc3MgPyBcImFjY29yZGlvblwiIDogb3B0aW9ucy5lbmFibGVkQ2xhc3MpO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWRDbGFzcyA9IG9wdGlvbnMuZGlzYWJsZWRDbGFzcztcclxuICAgICAgICB0aGlzLm1vZGFsID0gISFvcHRpb25zLm1vZGFsO1xyXG4gICAgICAgIHRoaXMubm9BcmlhID0gISFvcHRpb25zLm5vQXJpYTtcclxuICAgICAgICB0aGlzLm5vS2V5cyA9ICEhb3B0aW9ucy5ub0tleXM7XHJcbiAgICAgICAgdGhpcy5ub1RyYW5zZm9ybXMgPSAhIW9wdGlvbnMubm9UcmFuc2Zvcm1zO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0T2Zmc2V0ID0gK29wdGlvbnMuaGVpZ2h0T2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgdGhpcy51c2VCb3JkZXJzID0gdW5kZWZpbmVkID09PSBvcHRpb25zLnVzZUJvcmRlcnMgPyBcImF1dG9cIiA6IG9wdGlvbnMudXNlQm9yZGVycztcclxuICAgICAgICB0aGlzLm9uVG9nZ2xlID0gb3B0aW9ucy5vblRvZ2dsZTtcclxuXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGZvbGQgZm9yIGVhY2ggaW1tZWRpYXRlIGRlc2NlbmRhbnQgb2YgdGhlIEFjY29yZGlvbidzIGNvbnRhaW5lclxyXG4gICAgICAgIGxldCBmb2xkcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgb2YgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgbGV0IGZvbGQgPSBuZXcgRm9sZCh0aGlzLCBpKTtcclxuICAgICAgICAgICAgZm9sZHMucHVzaChmb2xkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGZvbGQgdG8gaXRzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCB0byBiZSBhZGRlZFxyXG4gICAgICAgICAgICBsZXQgcHJldiA9IGZvbGRzW2ZvbGRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICAgICAgcHJldi5uZXh0Rm9sZCA9IGZvbGQ7XHJcbiAgICAgICAgICAgICAgICBmb2xkLnByZXZpb3VzRm9sZCA9IHByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBlbC5hY2NvcmRpb24gPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIHRoaXMubm9BcmlhIHx8IGVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0YWJsaXN0XCIpO1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLmZvbGRzID0gZm9sZHM7XHJcblxyXG4gICAgICAgIC8vIEFkZCAuZW5hYmxlZENsYXNzIGVhcmx5IC0gaXQgbWlnaHQgYWZmZWN0IHRoZSBoZWlnaHRzIG9mIGVhY2ggZm9sZFxyXG4gICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlZCAmJiB0aGlzLmVuYWJsZWRDbGFzcylcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmVuYWJsZWRDbGFzcyk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG5cclxuICAgICAgICAvLyBGaW5kIG91dCBpZiB0aGlzIGFjY29yZGlvbidzIG5lc3RlZCBpbnNpZGUgYW5vdGhlclxyXG4gICAgICAgIGxldCBuZXh0ID0gZWw7XHJcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gbmV4dC5wYXJlbnROb2RlKSAmJiAxID09PSBuZXh0Lm5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBmb2xkID0gQWNjb3JkaW9uLmdldEZvbGQobmV4dCk7XHJcbiAgICAgICAgICAgIGlmIChmb2xkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWNjb3JkaW9uID0gZm9sZC5hY2NvcmRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IGFjY29yZGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Rm9sZCA9IGZvbGQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VDbGFzcyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZWRnZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIChhY2NvcmRpb24uY2hpbGRBY2NvcmRpb25zID0gYWNjb3JkaW9uLmNoaWxkQWNjb3JkaW9ucyB8fCBbXSkucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIChmb2xkLmNoaWxkQWNjb3JkaW9ucyA9IGZvbGQuY2hpbGRBY2NvcmRpb25zIHx8IFtdKS5wdXNoKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluaW5nIGZvbGQncyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9sZC5vcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjcm9sbEhlaWdodCA9IGZvbGQuZWwuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IChmb2xkLmhlYWRpbmdIZWlnaHQgKyBmb2xkLmNvbnRlbnQuc2Nyb2xsSGVpZ2h0KSAtIHNjcm9sbEhlaWdodCB8fCAoc2Nyb2xsSGVpZ2h0IC0gZm9sZC5lbC5jbGllbnRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY29yZGlvbi51cGRhdGVGb2xkKGZvbGQsIGRpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5lZGdlQ2xhc3MgJiYgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmQsIHRoaXMub25UcmFuc2l0aW9uRW5kID0gZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgZS50YXJnZXQgPT09IGVsICYmIFwiaGVpZ2h0XCIgPT09IGUucHJvcGVydHlOYW1lICYmIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA+IHdpbmRvdy5pbm5lckhlaWdodClcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5lZGdlQ2xhc3MpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gISFvcHRpb25zLmRpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGFjY29yZGlvbiBlbmNsb3NpbmcgdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKiBAdHlwZSB7QWNjb3JkaW9ufVxyXG4gICAgICovXHJcbiAgICBzZXQgcGFyZW50KGlucHV0KSB7IHRoaXMuX3BhcmVudCA9IGlucHV0OyB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCBhbmNlc3RvciB0aGF0ICppc24ndCogZGlzYWJsZWRcclxuICAgICAgICB3aGlsZSAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRpc2FibGVkKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBmb2xkIG9mIHRoZSBhY2NvcmRpb24gZW5jbG9zaW5nIHRoaXMgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICogQHR5cGUge0ZvbGR9XHJcbiAgICAgKi9cclxuICAgIHNldCBwYXJlbnRGb2xkKGlucHV0KSB7IHRoaXMuX3BhcmVudEZvbGQgPSBpbnB1dDsgfVxyXG4gICAgZ2V0IHBhcmVudEZvbGQoKSB7XHJcbiAgICAgICAgbGV0IGZvbGQgPSB0aGlzLl9wYXJlbnRGb2xkO1xyXG4gICAgICAgIGlmICghZm9sZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCBhY2NvcmRpb24gPSBmb2xkLmFjY29yZGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgZmlyc3QgYW5jZXN0b3IgdGhhdCAqaXNuJ3QqIGRpc2FibGVkXHJcbiAgICAgICAgd2hpbGUgKGZvbGQgJiYgYWNjb3JkaW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghYWNjb3JkaW9uLmRpc2FibGVkKSByZXR1cm4gZm9sZDtcclxuICAgICAgICAgICAgaWYgKGFjY29yZGlvbiA9IGFjY29yZGlvbi5wYXJlbnQpXHJcbiAgICAgICAgICAgICAgICBmb2xkID0gYWNjb3JkaW9uLnBhcmVudEZvbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGFjY29yZGlvbidzIGJlZW4gZGVhY3RpdmF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH1cclxuICAgIHNldCBkaXNhYmxlZChpbnB1dCkge1xyXG4gICAgICAgIGlmICgoaW5wdXQgPSAhIWlucHV0KSAhPT0gdGhpcy5fZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gZWwuY2xhc3NMaXN0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5lbmFibGVkQ2xhc3MgJiYgc2V0VG9rZW4oY2xhc3NlcywgdGhpcy5lbmFibGVkQ2xhc3MsICFpbnB1dCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWRDbGFzcyAmJiBzZXRUb2tlbihjbGFzc2VzLCB0aGlzLmRpc2FibGVkQ2xhc3MsIGlucHV0KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBEZWFjdGl2YXRpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkID0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBDbGFzcyAmJiBjbGFzc2VzLnJlbW92ZSh0aGlzLnNuYXBDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGdlQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmQsIHRoaXMub25UcmFuc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnJlbW92ZSh0aGlzLmVkZ2VDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBvZiB0aGlzLmZvbGRzKVxyXG4gICAgICAgICAgICAgICAgICAgIGkuZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubm9BcmlhIHx8IGVsLnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIik7XHJcbiAgICAgICAgICAgICAgICAtLWFjdGl2ZUFjY29yZGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBSZWFjdGl2YXRpbmdcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIG9mIHRoaXMuZm9sZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgaS5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubm9BcmlhIHx8IGVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0YWJsaXN0XCIpO1xyXG4gICAgICAgICAgICAgICAgKythY3RpdmVBY2NvcmRpb25zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBubyBtb3JlIGFjdGl2ZSBhY2NvcmRpb25zLCBkaXNhYmxlIHRoZSBvblJlc2l6ZSBoYW5kbGVyXHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVBY2NvcmRpb25zIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUFjY29yZGlvbnMgPSAwO1xyXG4gICAgICAgICAgICAgICAgQWNjb3JkaW9uLnNldFJlc2l6ZVJhdGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlYWN0aXZhdGUgdGhlIG9uUmVzaXplIGhhbmRsZXIsIGFzc3VtaW5nIGl0IHdhcyBwcmV2aW91c2x5IGFjdGl2ZVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0UmVzaXplUmF0ZSlcclxuICAgICAgICAgICAgICAgIEFjY29yZGlvbi5zZXRSZXNpemVSYXRlKGxhc3RSZXNpemVSYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlaWdodCBvZiB0aGUgYWNjb3JkaW9uJ3MgY29udGFpbmVyIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0OyB9XHJcbiAgICBzZXQgaGVpZ2h0KGlucHV0KSB7XHJcbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dCA9ICtpbnB1dCkgIT09IHRoaXMuX2hlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IGlucHV0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjaGVjayBpZiBhbiBhY2NvcmRpb24ncyBib3R0b20tZWRnZSBpcyB2aXNpYmxlIHRvIHRoZSB1c2VyIChvciBhYm91dCB0byBiZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZWRnZUNoZWNrKG9mZnNldCkge1xyXG4gICAgICAgIGxldCBlZGdlQ2xhc3MgPSB0aGlzLmVkZ2VDbGFzcztcclxuICAgICAgICBpZiAoZWRnZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIGxldCBib3ggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBsZXQgd2luZG93RWRnZSA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgbGV0IGNsYXNzZXMgPSB0aGlzLmVsLmNsYXNzTGlzdDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBib3R0b20tZWRnZSBpcyB2aXNpYmxlIChvciBhYm91dCB0byBiZSksIGVuYWJsZSBoZWlnaHQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgIGlmIChib3guYm90dG9tICsgKG9mZnNldCB8fCAwKSA8IHdpbmRvd0VkZ2UpXHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLmFkZChlZGdlQ2xhc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGJvdHRvbS1lZGdlIGlzbid0IHZpc2libGUgYW55d2F5LCBkaXNhYmxlIGhlaWdodCBhbmltYXRpb24gaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgZWxzZSBpZiAoYm94LmJvdHRvbSA+IHdpbmRvd0VkZ2UpXHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnJlbW92ZShlZGdlQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSB2ZXJ0aWNhbCBvcmRpbmF0ZSBvZiBlYWNoIHNpYmxpbmcgZm9yIGEgcGFydGljdWxhciBmb2xkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Rm9sZH0gZm9sZFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFBpeGVsIGRpc3RhbmNlIHRvIGFkanVzdCBieVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVGb2xkKGZvbGQsIG9mZnNldCkge1xyXG4gICAgICAgIGxldCBuZXh0ID0gZm9sZDtcclxuICAgICAgICBsZXQgcGFyZW50Rm9sZCA9IHRoaXMucGFyZW50Rm9sZDtcclxuXHJcbiAgICAgICAgd2hpbGUgKG5leHQgPSBuZXh0Lm5leHRGb2xkKVxyXG4gICAgICAgICAgICBuZXh0LnkgKz0gb2Zmc2V0O1xyXG4gICAgICAgIHBhcmVudEZvbGQgfHwgdGhpcy5lZGdlQ2hlY2sob2Zmc2V0KTtcclxuICAgICAgICBmb2xkLmhlaWdodCArPSBvZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gb2Zmc2V0O1xyXG5cclxuICAgICAgICBwYXJlbnRGb2xkICYmIHBhcmVudEZvbGQub3BlbiAmJiB0aGlzLnBhcmVudC51cGRhdGVGb2xkKHBhcmVudEZvbGQsIG9mZnNldCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBoZWlnaHQgb2YgZWFjaCBmb2xkIHRvIGZpdCBpdHMgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpIG9mIHRoaXMuZm9sZHMpIHtcclxuICAgICAgICAgICAgaS55ID0geTtcclxuICAgICAgICAgICAgaS5maXQoKTtcclxuICAgICAgICAgICAgeSArPSBpLmhlaWdodDtcclxuICAgICAgICAgICAgaGVpZ2h0ICs9IGkuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBhcmVudEZvbGQgPSB0aGlzLnBhcmVudEZvbGQ7XHJcbiAgICAgICAgbGV0IGRpZmYgPSBoZWlnaHQgLSB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgcGFyZW50Rm9sZFxyXG4gICAgICAgICAgICA/XHJcbiAgICAgICAgICAgIChwYXJlbnRGb2xkLm9wZW4gJiYgdGhpcy5wYXJlbnQudXBkYXRlRm9sZChwYXJlbnRGb2xkLCBkaWZmKSkgOlxyXG4gICAgICAgICAgICB0aGlzLmVkZ2VDaGVjayhkaWZmKTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlIHRoZSBib3VuZGFyaWVzIG9mIGFuIEFjY29yZGlvbiBhbmQgaXRzIGRlc2NlbmRhbnRzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgd2lkdGggb2YgYSBjb250YWluZXIgY2hhbmdlcyxcclxuICAgICAqIG9yIGEgZm9sZCdzIGNvbnRlbnRzIGhhdmUgcmVzaXplZCB1bmV4cGVjdGVkbHkgKHN1Y2ggYXMgd2hlbiBpbWFnZXMgbG9hZCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvd1NuYXAgLSBTbmFwIGZvbGRzIGluc3RhbnRseSBpbnRvIHBsYWNlIHdpdGhvdXQgdHJhbnNpdGlvbmluZ1xyXG4gICAgICovXHJcbiAgICByZWZyZXNoKGFsbG93U25hcCkge1xyXG4gICAgICAgIGxldCBzbmFwID0gYWxsb3dTbmFwID8gdGhpcy5zbmFwQ2xhc3MgOiBmYWxzZTtcclxuICAgICAgICBzbmFwICYmIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChzbmFwKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZEFjY29yZGlvbnMpXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRBY2NvcmRpb25zLmZvckVhY2goYSA9PiBhLnBhcmVudEZvbGQub3BlbiA/XHJcbiAgICAgICAgICAgICAgICBhLnJlZnJlc2goYWxsb3dTbmFwKSA6XHJcbiAgICAgICAgICAgICAgICAoYS5wYXJlbnRGb2xkLm5lZWRzUmVmcmVzaCA9IHRydWUpKTtcclxuXHJcbiAgICAgICAgc25hcCAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShzbmFwKSwgMjApO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG9uZSBvZiB0aGUgQWNjb3JkaW9uJ3MgZm9sZHMgaGFzIGJlZW4gcmVzaXplZCBpbmNvcnJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIGdldCB3cm9uZ1NpemUoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSBvZiB0aGlzLmZvbGRzKVxyXG4gICAgICAgICAgICBpZiAoaS53cm9uZ1NpemUpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkQWNjb3JkaW9ucylcclxuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiB0aGlzLmNoaWxkQWNjb3JkaW9ucylcclxuICAgICAgICAgICAgICAgIGlmIChpLndyb25nU2l6ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHRvcC1sZXZlbCBhbmNlc3RvciB0aGlzIGFjY29yZGlvbidzIG5lc3RlZCBpbnNpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0FjY29yZGlvbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIGdldCByb290KCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQucGFyZW50KSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbHRlciB0aGUgcmF0ZSBhdCB3aGljaCBzY3JlZW4tcmVzaXplIGV2ZW50cyB1cGRhdGUgYWNjb3JkaW9uIHdpZHRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBSYXRlIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNldFJlc2l6ZVJhdGUoZGVsYXkpIHtcclxuICAgICAgICBsZXQgZm4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBhY2NvcmRpb25zKVxyXG4gICAgICAgICAgICAgICAgaS5wYXJlbnQgfHwgaS5kaXNhYmxlZCB8fCBpLnJlZnJlc2godHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB3ZXJlbid0IHBhc3NlZCBhbiBleHBsaWNpdCB2YWx1ZSBvZiBGQUxTRSwgb3IgYSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICAgIGlmIChmYWxzZSAhPT0gZGVsYXkgJiYgKGRlbGF5ID0gK2RlbGF5IHx8IDApID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSA9IGRlbGF5ID8gZGVib3VuY2UoZm4sIGRlbGF5KSA6IGZuO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5KSBsYXN0UmVzaXplUmF0ZSA9IGRlbGF5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjbG9zZXN0IChtb3N0IGRlZXBseS1uZXN0ZWQpIGFjY29yZGlvbiBlbmNsb3NpbmcgYW4gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm4ge0FjY29yZGlvbn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFjY29yZGlvbihub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKFwiYWNjb3JkaW9uXCIgaW4gbm9kZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2NvcmRpb25zW25vZGUuYWNjb3JkaW9uXTtcclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjbG9zZXN0IChtb3N0IGRlZXBseS1uZXN0ZWQpIGZvbGQgZW5jbG9zaW5nIGFuIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHtGb2xkfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0Rm9sZChub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKFwiYWNjb3JkaW9uRm9sZFwiIGluIG5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZHNbbm9kZS5hY2NvcmRpb25Gb2xkXTtcclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5BY2NvcmRpb24uc2V0UmVzaXplUmF0ZSgyNSk7XHJcbndpbmRvdy5BY2NvcmRpb24gPSBBY2NvcmRpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/accordion.mjs\n");

/***/ }),

/***/ "./src/js/fold.mjs":
/*!*************************!*\
  !*** ./src/js/fold.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fold),\n/* harmony export */   \"folds\": () => (/* binding */ folds)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/js/helpers.mjs\");\n\r\n\r\nconst folds = [];\r\n\r\n\r\n/**\r\n * Represents a single panel of togglable content inside an Accordion.\r\n *\r\n * @class\r\n */\r\nclass Fold {\r\n\r\n    /**\r\n     * Instantiate a new Fold instance.\r\n     *\r\n     * @param {Accordion} accordion\r\n     * @param {HTMLElement} el\r\n     * @constructor\r\n     */\r\n    constructor(accordion, el) {\r\n        let heading = el.firstElementChild;\r\n        let content = el.lastElementChild;\r\n        let useBorders = accordion.useBorders;\r\n\r\n        this.index = folds.push(this) - 1;\r\n        this.accordion = accordion;\r\n        this.el = el;\r\n        this.heading = heading;\r\n        this.content = content;\r\n        this.openClass = accordion.openClass;\r\n        this.closeClass = accordion.closeClass;\r\n        this.ariaEnabled = !accordion.noAria;\r\n        this.heightOffset = accordion.heightOffset;\r\n        this.useBorders = \"auto\" === useBorders ? (0 !== this.elBorder + this.headingBorder) : useBorders;\r\n        this.useTransforms = !accordion.noTransforms && _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.cssTransform;\r\n        this.onToggle = accordion.onToggle;\r\n        el.accordionFold = this.index;\r\n\r\n\r\n        // Keyboard navigation\r\n        if (!accordion.noKeys) {\r\n            heading.tabIndex = 0;\r\n            heading.addEventListener(\"keydown\", this.onKeyDown = e => {\r\n                const key = e.keyCode;\r\n                let fold;\r\n\r\n                switch (key) {\r\n\r\n                    // Spacebar: Toggle\r\n                    case 32:\r\n                        e.preventDefault(); // Fall-through\r\n\r\n\r\n                        // Enter: Toggle\r\n                    case 13:\r\n                        this.open = !this.open;\r\n                        if (\"A\" === e.target.tagName)\r\n                            e.preventDefault();\r\n                        break;\r\n\r\n\r\n                        // Escape: Clear focus\r\n                    case 27:\r\n                        e.target.blur();\r\n                        break;\r\n\r\n\r\n                        // Up arrow: Previous section\r\n                    case 38:\r\n                        {\r\n\r\n                            // Is there a previous sibling to navigate up to?\r\n                            if (fold = this.previousFold) {\r\n                                let children = fold.childAccordions;\r\n\r\n                                // Is it open, and does it have nested accordions?\r\n                                if (fold.open && children) {\r\n                                    let lastAcc;\r\n                                    let lastFold;\r\n\r\n                                    // Locate the deepest/nearest accordion that's currently exposed\r\n                                    while (children) {\r\n                                        lastAcc = children[children.length - 1];\r\n                                        lastFold = lastAcc.folds[lastAcc.folds.length - 1];\r\n                                        if (!lastFold.open) break;\r\n                                        children = lastFold.childAccordions;\r\n                                    }\r\n\r\n                                    lastFold.heading.focus();\r\n                                }\r\n\r\n                                // Nope\r\n                                else fold.heading.focus();\r\n                            }\r\n\r\n                            // Is there a higher level we can jump back up to?\r\n                            else if (this.accordion.parent)\r\n                                this.accordion.parentFold.heading.focus();\r\n\r\n                            // There's nothing to move back to, so just let the browser run its usual behaviour\r\n                            else return true;\r\n\r\n                            e.preventDefault();\r\n                            return false;\r\n                        }\r\n\r\n\r\n\r\n                        // Down arrow: Next section\r\n                    case 40:\r\n                        {\r\n                            const children = this.childAccordions;\r\n\r\n                            // Is there a nested accordion to jump into?\r\n                            if (this.open && children)\r\n                                children[0].folds[0].heading.focus();\r\n\r\n                            // No, there isn't. Is there another sibling to move down to?\r\n                            else if (fold = this.nextFold)\r\n                                fold.heading.focus();\r\n\r\n                            // Is there a containing accordion we can navigate back up to?\r\n                            else if (this.accordion.parent) {\r\n                                let parent = this;\r\n                                while (parent = parent.accordion.parentFold)\r\n                                    if (fold = parent.nextFold) {\r\n                                        fold.heading.focus();\r\n                                        break;\r\n                                    }\r\n\r\n                                    // Nowhere left to go...\r\n                                if (!parent) return true;\r\n                            }\r\n\r\n                            // Nah. Just scroll the window normally, as per browser default\r\n                            else return true;\r\n\r\n                            e.preventDefault();\r\n                            return false;\r\n                        }\r\n\r\n\r\n                        // Left arrow\r\n                    case 37:\r\n                        {\r\n\r\n                            // Close an opened section\r\n                            if (this.open) this.open = false;\r\n\r\n                            // Switch focus back to parent\r\n                            else if (this.accordion.parent)\r\n                                this.accordion.parentFold.heading.focus();\r\n\r\n                            break;\r\n                        }\r\n\r\n                        // Right arrow\r\n                    case 39:\r\n                        {\r\n\r\n                            // Open a closed section\r\n                            if (!this.open) this.open = true;\r\n\r\n                            // Switch focus to a nested accordion\r\n                            else if (this.childAccordions)\r\n                                this.childAccordions[0].folds[0].heading.focus();\r\n\r\n                            break;\r\n                        }\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        // Listener to record the viewport's scroll offsets at the beginning of a touch\r\n        let scrollX, scrollY;\r\n        _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.touchEnabled && heading.addEventListener(\"touchstart\", this.onTouchStart = () => {\r\n            scrollX = window.pageXOffset;\r\n            scrollY = window.pageYOffset;\r\n        }, { passive: true });\r\n\r\n\r\n        heading.addEventListener(_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.pressEvent, this.onPress = e => {\r\n\r\n            // Pressed on something inside the header\r\n            if (e.target !== heading && heading.contains(e.target)) {\r\n\r\n                // Cancel fold-toggle if user clicked on an anchor-link\r\n                if (\"A\" === e.target.tagName && e.target.href)\r\n                    return true;\r\n            }\r\n\r\n            if (e.type !== \"touchend\" || (e.cancelable && window.pageXOffset === scrollX && window.pageYOffset === scrollY)) {\r\n                this.open = !this.open;\r\n                e.preventDefault();\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Adjust a fold's container to fit its content.\r\n     */\r\n    fit() {\r\n        let height = this.headingHeight;\r\n        if (this.open) height += this.content.scrollHeight;\r\n        if (this.useBorders) height += this.elBorder;\r\n        this.height = height;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Add or remove relevant ARIA attributes from the fold's elements.\r\n     *\r\n     * @property\r\n     * @type {Boolean}\r\n     */\r\n    get ariaEnabled() { return this._ariaEnabled; }\r\n    set ariaEnabled(input) {\r\n        if ((input = !!input) !== !!this._ariaEnabled) {\r\n            const heading = this.heading;\r\n            const content = this.content;\r\n            this._ariaEnabled = input;\r\n\r\n            // Enable ARIA-attribute management\r\n            if (input) {\r\n                heading.setAttribute(\"role\", \"tab\");\r\n                content.setAttribute(\"role\", \"tabpanel\");\r\n\r\n\r\n                // Ensure the fold's elements have unique ID attributes.\r\n                const headingSuffix = \"-heading\";\r\n                const contentSuffix = \"-content\";\r\n                let elID = this.el.id;\r\n                let id;\r\n\r\n                // Neither of the fold's elements have an ID attribute\r\n                if (!heading.id && !content.id) {\r\n                    id = elID || (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueID)(\"a\");\r\n                    heading.id = id + headingSuffix;\r\n                    content.id = id + contentSuffix;\r\n                }\r\n\r\n                // Either the heading or element lack an ID\r\n                else if (!content.id) content.id = (elID || heading.id) + contentSuffix;\r\n                else if (!heading.id) heading.id = (elID || content.id) + headingSuffix;\r\n\r\n                // Finally, double-check each element's ID is really unique\r\n                const $ = s => document.querySelectorAll(\"#\" + s);\r\n                while ($(content.id).length > 1 || $(heading.id).length > 1) {\r\n                    id = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueID)(\"a\");\r\n                    content.id = id + contentSuffix;\r\n                    heading.id = id + headingSuffix;\r\n                }\r\n\r\n                // Update ARIA attributes\r\n                heading.setAttribute(\"aria-controls\", content.id);\r\n                content.setAttribute(\"aria-labelledby\", heading.id);\r\n\r\n\r\n                // Update the attributes that're controlled by .open's setter\r\n                heading.setAttribute(\"aria-selected\", !!this._open);\r\n                heading.setAttribute(\"aria-expanded\", !!this._open);\r\n                content.setAttribute(\"aria-hidden\", !this._open);\r\n            }\r\n\r\n            // Disabling; remove all relevant attributes\r\n            else {\r\n                heading.removeAttribute(\"role\");\r\n                heading.removeAttribute(\"aria-controls\");\r\n                heading.removeAttribute(\"aria-selected\");\r\n                heading.removeAttribute(\"aria-expanded\");\r\n\r\n                content.removeAttribute(\"role\");\r\n                content.removeAttribute(\"aria-labelledby\");\r\n                content.removeAttribute(\"aria-hidden\");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Whether or not the fold's currently opened.\r\n     *\r\n     * @property\r\n     * @type {Boolean}\r\n     */\r\n    get open() {\r\n\r\n        // Derive the fold's opened state from the DOM if it's not been determined yet\r\n        if (undefined === this._open) {\r\n            const classes = this.el.classList;\r\n            this._open = classes.contains(this.openClass);\r\n            (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setToken)(classes, this.closeClass, !this._open);\r\n        }\r\n\r\n        return this._open;\r\n    }\r\n\r\n    set open(input) {\r\n        if ((input = !!input) !== this._open) {\r\n\r\n            // If an onToggle callback was specified, run it. Avoid doing anything if it returns false.\r\n            if (\"function\" === typeof this.onToggle && false === this.onToggle.call(null, this, input))\r\n                return;\r\n\r\n            (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setToken)(this.el.classList, this.openClass, input);\r\n            (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setToken)(this.el.classList, this.closeClass, !input);\r\n            this._open = input;\r\n\r\n            // Update ARIA attributes\r\n            if (this.ariaEnabled) {\r\n                const heading = this.heading;\r\n                heading.setAttribute(\"aria-selected\", input);\r\n                heading.setAttribute(\"aria-expanded\", input);\r\n                this.content.setAttribute(\"aria-hidden\", !input);\r\n            }\r\n\r\n            // If this fold was closed when the screen resized, run a full update in case its contents were juggled around\r\n            if (this.needsRefresh) {\r\n                delete this.needsRefresh;\r\n                this.accordion.refresh();\r\n            } else this.accordion.update();\r\n\r\n            // Close other folds if accordion is modal\r\n            if (this.accordion.modal && input) {\r\n                for (const fold of this.accordion.folds)\r\n                    if (this !== fold) fold.open = false;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Whether the fold's been deactivated.\r\n     *\r\n     * Not set directly; changed when setting an accordion's .disabled property.\r\n     *\r\n     * @property\r\n     * @type {Boolean}\r\n     */\r\n    get disabled() { return this._disabled; }\r\n    set disabled(input) {\r\n        if ((input = !!input) !== !!this._disabled) {\r\n            let heading = this.heading;\r\n            let style = this.el.style;\r\n            let classes = this.el.classList;\r\n\r\n            // Deactivated\r\n            if (this._disabled = input) {\r\n                style.height = null;\r\n                this.useTransforms ?\r\n                    (style[_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.cssTransform] = null) :\r\n                    (style.top = null);\r\n\r\n                _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.touchEnabled && heading.removeEventListener(\"touchstart\", this.onTouchStart);\r\n                heading.removeEventListener(_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.pressEvent, this.onPress);\r\n                classes.remove(this.openClass, this.closeClass);\r\n                if (this.onKeyDown) {\r\n                    heading.removeEventListener(\"keydown\", this.onKeyDown);\r\n                    heading.removeAttribute(\"tabindex\");\r\n                }\r\n\r\n                if (this.ariaEnabled) {\r\n                    this.ariaEnabled = false;\r\n                    this._ariaEnabled = true;\r\n                }\r\n            }\r\n\r\n            // Reactivated\r\n            else {\r\n                style.height = this._height + \"px\";\r\n                this.useTransforms ?\r\n                    style[_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.cssTransform] =\r\n                    _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.css3DSupported ?\r\n                    (\"translate3D(0,\" + this._y + \"px,0)\") :\r\n                    (\"translateY(\" + this._y + \"px)\") :\r\n                    (style.top = this._y + \"px\");\r\n\r\n                _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.touchEnabled && heading.addEventListener(\"touchstart\", this.onTouchStart);\r\n                heading.addEventListener(_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.pressEvent, this.onPress);\r\n\r\n                if (this.onKeyDown) {\r\n                    heading.addEventListener(\"keydown\", this.onKeyDown);\r\n                    heading.tabIndex = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Vertical position of the fold within an accordion's container.\r\n     *\r\n     * @property\r\n     * @type {Number}\r\n     */\r\n    get y() {\r\n        if (undefined === this._y)\r\n            return (this._y = parseInt(this.el.style.top) || 0);\r\n        return this._y;\r\n    }\r\n\r\n    set y(input) {\r\n        if ((input = +input) !== this._y) {\r\n            this._y = input;\r\n            const style = this.el.style;\r\n            this.useTransforms ?\r\n                style[_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.cssTransform] =\r\n                _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.css3DSupported ?\r\n                (\"translate3D(0,\" + input + \"px,0)\") :\r\n                (\"translateY(\" + input + \"px)\") :\r\n                (style.top = input + \"px\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Height of the fold's outermost container.\r\n     *\r\n     * @property\r\n     * @type {Number}\r\n     */\r\n    get height() {\r\n        if (undefined === this._height) {\r\n            let height = this.headingHeight + this.content.scrollHeight;\r\n            this.el.style.height = height + \"px\";\r\n            return (this._height = height);\r\n        }\r\n        return this._height;\r\n    }\r\n\r\n    set height(input) {\r\n        if (input && (input = +input) !== this._height) {\r\n            this.el.style.height = input + \"px\";\r\n            this._height = input;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Current height of the fold's heading.\r\n     *\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get headingHeight() {\r\n        return this.heading.scrollHeight +\r\n            this.heightOffset +\r\n            (this.useBorders ? this.headingBorder : 0);\r\n    }\r\n\r\n    /**\r\n     * Total height consumed by the heading element's CSS borders, if any.\r\n     *\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get headingBorder() {\r\n        let heading = this.heading;\r\n        return (heading.offsetHeight || 0) - (heading.clientHeight || 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Total height of the fold's container element.\r\n     *\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get elHeight() {\r\n        return this.el.scrollHeight + (this.useBorders ? this.elBorder : 0);\r\n    }\r\n\r\n    /**\r\n     * Total height consumed by container element's CSS borders, if any.\r\n     * \r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get elBorder() {\r\n        let el = this.el;\r\n        return (el.offsetHeight || 0) - (el.clientHeight || 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Whether the fold's container has been resized incorrectly.\r\n     *\r\n     * @type {Boolean}\r\n     * @readonly\r\n     * @property\r\n     */\r\n    get wrongSize() {\r\n        return this.headingHeight + this.content.scrollHeight !== this.el.scrollHeight;\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGdlb3Rvb2xraXQvZ2VvdG9vbGtpdC8uL3NyYy9qcy9mb2xkLm1qcz81NWZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICB0b3VjaEVuYWJsZWQsXHJcbiAgICBwcmVzc0V2ZW50LFxyXG4gICAgc2V0VG9rZW4sXHJcbiAgICB1bmlxdWVJRCxcclxuICAgIGNzc1RyYW5zZm9ybSxcclxuICAgIGNzczNEU3VwcG9ydGVkLFxyXG59IGZyb20gXCIuL2hlbHBlcnMubWpzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZm9sZHMgPSBbXTtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYW5lbCBvZiB0b2dnbGFibGUgY29udGVudCBpbnNpZGUgYW4gQWNjb3JkaW9uLlxyXG4gKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbGQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgRm9sZCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FjY29yZGlvbn0gYWNjb3JkaW9uXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFjY29yZGlvbiwgZWwpIHtcclxuICAgICAgICBsZXQgaGVhZGluZyA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICBsZXQgdXNlQm9yZGVycyA9IGFjY29yZGlvbi51c2VCb3JkZXJzO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4ID0gZm9sZHMucHVzaCh0aGlzKSAtIDE7XHJcbiAgICAgICAgdGhpcy5hY2NvcmRpb24gPSBhY2NvcmRpb247XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMuaGVhZGluZyA9IGhlYWRpbmc7XHJcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcclxuICAgICAgICB0aGlzLm9wZW5DbGFzcyA9IGFjY29yZGlvbi5vcGVuQ2xhc3M7XHJcbiAgICAgICAgdGhpcy5jbG9zZUNsYXNzID0gYWNjb3JkaW9uLmNsb3NlQ2xhc3M7XHJcbiAgICAgICAgdGhpcy5hcmlhRW5hYmxlZCA9ICFhY2NvcmRpb24ubm9BcmlhO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0T2Zmc2V0ID0gYWNjb3JkaW9uLmhlaWdodE9mZnNldDtcclxuICAgICAgICB0aGlzLnVzZUJvcmRlcnMgPSBcImF1dG9cIiA9PT0gdXNlQm9yZGVycyA/ICgwICE9PSB0aGlzLmVsQm9yZGVyICsgdGhpcy5oZWFkaW5nQm9yZGVyKSA6IHVzZUJvcmRlcnM7XHJcbiAgICAgICAgdGhpcy51c2VUcmFuc2Zvcm1zID0gIWFjY29yZGlvbi5ub1RyYW5zZm9ybXMgJiYgY3NzVHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMub25Ub2dnbGUgPSBhY2NvcmRpb24ub25Ub2dnbGU7XHJcbiAgICAgICAgZWwuYWNjb3JkaW9uRm9sZCA9IHRoaXMuaW5kZXg7XHJcblxyXG5cclxuICAgICAgICAvLyBLZXlib2FyZCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgaWYgKCFhY2NvcmRpb24ubm9LZXlzKSB7XHJcbiAgICAgICAgICAgIGhlYWRpbmcudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBoZWFkaW5nLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBlLmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9sZDtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTcGFjZWJhcjogVG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBGYWxsLXRocm91Z2hcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnRlcjogVG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQVwiID09PSBlLnRhcmdldC50YWdOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGU6IENsZWFyIGZvY3VzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcCBhcnJvdzogUHJldmlvdXMgc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIHByZXZpb3VzIHNpYmxpbmcgdG8gbmF2aWdhdGUgdXAgdG8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZCA9IHRoaXMucHJldmlvdXNGb2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gZm9sZC5jaGlsZEFjY29yZGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGl0IG9wZW4sIGFuZCBkb2VzIGl0IGhhdmUgbmVzdGVkIGFjY29yZGlvbnM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGQub3BlbiAmJiBjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEFjYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RGb2xkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBkZWVwZXN0L25lYXJlc3QgYWNjb3JkaW9uIHRoYXQncyBjdXJyZW50bHkgZXhwb3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RBY2MgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGb2xkID0gbGFzdEFjYy5mb2xkc1tsYXN0QWNjLmZvbGRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0Rm9sZC5vcGVuKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gbGFzdEZvbGQuY2hpbGRBY2NvcmRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9sZC5oZWFkaW5nLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBmb2xkLmhlYWRpbmcuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGhpZ2hlciBsZXZlbCB3ZSBjYW4ganVtcCBiYWNrIHVwIHRvP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY2NvcmRpb24ucGFyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uLnBhcmVudEZvbGQuaGVhZGluZy5mb2N1cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm90aGluZyB0byBtb3ZlIGJhY2sgdG8sIHNvIGp1c3QgbGV0IHRoZSBicm93c2VyIHJ1biBpdHMgdXN1YWwgYmVoYXZpb3VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3duIGFycm93OiBOZXh0IHNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRBY2NvcmRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgbmVzdGVkIGFjY29yZGlvbiB0byBqdW1wIGludG8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcGVuICYmIGNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuWzBdLmZvbGRzWzBdLmhlYWRpbmcuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObywgdGhlcmUgaXNuJ3QuIElzIHRoZXJlIGFub3RoZXIgc2libGluZyB0byBtb3ZlIGRvd24gdG8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb2xkID0gdGhpcy5uZXh0Rm9sZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xkLmhlYWRpbmcuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGNvbnRhaW5pbmcgYWNjb3JkaW9uIHdlIGNhbiBuYXZpZ2F0ZSBiYWNrIHVwIHRvP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY2NvcmRpb24ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5hY2NvcmRpb24ucGFyZW50Rm9sZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGQgPSBwYXJlbnQubmV4dEZvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGQuaGVhZGluZy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vd2hlcmUgbGVmdCB0byBnby4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOYWguIEp1c3Qgc2Nyb2xsIHRoZSB3aW5kb3cgbm9ybWFsbHksIGFzIHBlciBicm93c2VyIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBhcnJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhbiBvcGVuZWQgc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbikgdGhpcy5vcGVuID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpdGNoIGZvY3VzIGJhY2sgdG8gcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFjY29yZGlvbi5wYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2NvcmRpb24ucGFyZW50Rm9sZC5oZWFkaW5nLmZvY3VzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTpcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gYSBjbG9zZWQgc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHRoaXMub3BlbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpdGNoIGZvY3VzIHRvIGEgbmVzdGVkIGFjY29yZGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZEFjY29yZGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZEFjY29yZGlvbnNbMF0uZm9sZHNbMF0uaGVhZGluZy5mb2N1cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIExpc3RlbmVyIHRvIHJlY29yZCB0aGUgdmlld3BvcnQncyBzY3JvbGwgb2Zmc2V0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdG91Y2hcclxuICAgICAgICBsZXQgc2Nyb2xsWCwgc2Nyb2xsWTtcclxuICAgICAgICB0b3VjaEVuYWJsZWQgJiYgaGVhZGluZy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uVG91Y2hTdGFydCA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgc2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcblxyXG5cclxuICAgICAgICBoZWFkaW5nLmFkZEV2ZW50TGlzdGVuZXIocHJlc3NFdmVudCwgdGhpcy5vblByZXNzID0gZSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVzc2VkIG9uIHNvbWV0aGluZyBpbnNpZGUgdGhlIGhlYWRlclxyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGhlYWRpbmcgJiYgaGVhZGluZy5jb250YWlucyhlLnRhcmdldCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgZm9sZC10b2dnbGUgaWYgdXNlciBjbGlja2VkIG9uIGFuIGFuY2hvci1saW5rXHJcbiAgICAgICAgICAgICAgICBpZiAoXCJBXCIgPT09IGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQuaHJlZilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGUudHlwZSAhPT0gXCJ0b3VjaGVuZFwiIHx8IChlLmNhbmNlbGFibGUgJiYgd2luZG93LnBhZ2VYT2Zmc2V0ID09PSBzY3JvbGxYICYmIHdpbmRvdy5wYWdlWU9mZnNldCA9PT0gc2Nyb2xsWSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgYSBmb2xkJ3MgY29udGFpbmVyIHRvIGZpdCBpdHMgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgZml0KCkge1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmhlYWRpbmdIZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMub3BlbikgaGVpZ2h0ICs9IHRoaXMuY29udGVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMudXNlQm9yZGVycykgaGVpZ2h0ICs9IHRoaXMuZWxCb3JkZXI7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBvciByZW1vdmUgcmVsZXZhbnQgQVJJQSBhdHRyaWJ1dGVzIGZyb20gdGhlIGZvbGQncyBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgYXJpYUVuYWJsZWQoKSB7IHJldHVybiB0aGlzLl9hcmlhRW5hYmxlZDsgfVxyXG4gICAgc2V0IGFyaWFFbmFibGVkKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKChpbnB1dCA9ICEhaW5wdXQpICE9PSAhIXRoaXMuX2FyaWFFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmcgPSB0aGlzLmhlYWRpbmc7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2FyaWFFbmFibGVkID0gaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBFbmFibGUgQVJJQS1hdHRyaWJ1dGUgbWFuYWdlbWVudFxyXG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYlwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYnBhbmVsXCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZvbGQncyBlbGVtZW50cyBoYXZlIHVuaXF1ZSBJRCBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGluZ1N1ZmZpeCA9IFwiLWhlYWRpbmdcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdWZmaXggPSBcIi1jb250ZW50XCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWxJRCA9IHRoaXMuZWwuaWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVpdGhlciBvZiB0aGUgZm9sZCdzIGVsZW1lbnRzIGhhdmUgYW4gSUQgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRpbmcuaWQgJiYgIWNvbnRlbnQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IGVsSUQgfHwgdW5pcXVlSUQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRpbmcuaWQgPSBpZCArIGhlYWRpbmdTdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5pZCA9IGlkICsgY29udGVudFN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgdGhlIGhlYWRpbmcgb3IgZWxlbWVudCBsYWNrIGFuIElEXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29udGVudC5pZCkgY29udGVudC5pZCA9IChlbElEIHx8IGhlYWRpbmcuaWQpICsgY29udGVudFN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFoZWFkaW5nLmlkKSBoZWFkaW5nLmlkID0gKGVsSUQgfHwgY29udGVudC5pZCkgKyBoZWFkaW5nU3VmZml4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGRvdWJsZS1jaGVjayBlYWNoIGVsZW1lbnQncyBJRCBpcyByZWFsbHkgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICBjb25zdCAkID0gcyA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiI1wiICsgcyk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoJChjb250ZW50LmlkKS5sZW5ndGggPiAxIHx8ICQoaGVhZGluZy5pZCkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gdW5pcXVlSUQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaWQgPSBpZCArIGNvbnRlbnRTdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZy5pZCA9IGlkICsgaGVhZGluZ1N1ZmZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgQVJJQSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgY29udGVudC5pZCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBoZWFkaW5nLmlkKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIHRoYXQncmUgY29udHJvbGxlZCBieSAub3BlbidzIHNldHRlclxyXG4gICAgICAgICAgICAgICAgaGVhZGluZy5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEhdGhpcy5fb3Blbik7XHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgISF0aGlzLl9vcGVuKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgIXRoaXMuX29wZW4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhYmxpbmc7IHJlbW92ZSBhbGwgcmVsZXZhbnQgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKTtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiKTtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIik7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBmb2xkJ3MgY3VycmVudGx5IG9wZW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgb3BlbigpIHtcclxuXHJcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBmb2xkJ3Mgb3BlbmVkIHN0YXRlIGZyb20gdGhlIERPTSBpZiBpdCdzIG5vdCBiZWVuIGRldGVybWluZWQgeWV0XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGhpcy5fb3Blbikge1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5lbC5jbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSBjbGFzc2VzLmNvbnRhaW5zKHRoaXMub3BlbkNsYXNzKTtcclxuICAgICAgICAgICAgc2V0VG9rZW4oY2xhc3NlcywgdGhpcy5jbG9zZUNsYXNzLCAhdGhpcy5fb3Blbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgb3BlbihpbnB1dCkge1xyXG4gICAgICAgIGlmICgoaW5wdXQgPSAhIWlucHV0KSAhPT0gdGhpcy5fb3Blbikge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYW4gb25Ub2dnbGUgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcnVuIGl0LiBBdm9pZCBkb2luZyBhbnl0aGluZyBpZiBpdCByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdGhpcy5vblRvZ2dsZSAmJiBmYWxzZSA9PT0gdGhpcy5vblRvZ2dsZS5jYWxsKG51bGwsIHRoaXMsIGlucHV0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHNldFRva2VuKHRoaXMuZWwuY2xhc3NMaXN0LCB0aGlzLm9wZW5DbGFzcywgaW5wdXQpO1xyXG4gICAgICAgICAgICBzZXRUb2tlbih0aGlzLmVsLmNsYXNzTGlzdCwgdGhpcy5jbG9zZUNsYXNzLCAhaW5wdXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgQVJJQSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFyaWFFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gdGhpcy5oZWFkaW5nO1xyXG4gICAgICAgICAgICAgICAgaGVhZGluZy5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGhlYWRpbmcuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgIWlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBmb2xkIHdhcyBjbG9zZWQgd2hlbiB0aGUgc2NyZWVuIHJlc2l6ZWQsIHJ1biBhIGZ1bGwgdXBkYXRlIGluIGNhc2UgaXRzIGNvbnRlbnRzIHdlcmUganVnZ2xlZCBhcm91bmRcclxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5uZWVkc1JlZnJlc2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLmFjY29yZGlvbi51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENsb3NlIG90aGVyIGZvbGRzIGlmIGFjY29yZGlvbiBpcyBtb2RhbFxyXG4gICAgICAgICAgICBpZiAodGhpcy5hY2NvcmRpb24ubW9kYWwgJiYgaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm9sZCBvZiB0aGlzLmFjY29yZGlvbi5mb2xkcylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gZm9sZCkgZm9sZC5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGZvbGQncyBiZWVuIGRlYWN0aXZhdGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdCBzZXQgZGlyZWN0bHk7IGNoYW5nZWQgd2hlbiBzZXR0aW5nIGFuIGFjY29yZGlvbidzIC5kaXNhYmxlZCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgZGlzYWJsZWQoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfVxyXG4gICAgc2V0IGRpc2FibGVkKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKChpbnB1dCA9ICEhaW5wdXQpICE9PSAhIXRoaXMuX2Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGxldCBoZWFkaW5nID0gdGhpcy5oZWFkaW5nO1xyXG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NlcyA9IHRoaXMuZWwuY2xhc3NMaXN0O1xyXG5cclxuICAgICAgICAgICAgLy8gRGVhY3RpdmF0ZWRcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkID0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVRyYW5zZm9ybXMgP1xyXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZVtjc3NUcmFuc2Zvcm1dID0gbnVsbCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS50b3AgPSBudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0b3VjaEVuYWJsZWQgJiYgaGVhZGluZy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uVG91Y2hTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBoZWFkaW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIocHJlc3NFdmVudCwgdGhpcy5vblByZXNzKTtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucmVtb3ZlKHRoaXMub3BlbkNsYXNzLCB0aGlzLmNsb3NlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25LZXlEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93bik7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZy5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmlhRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJpYUVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmlhRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlYWN0aXZhdGVkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51c2VUcmFuc2Zvcm1zID9cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVtjc3NUcmFuc2Zvcm1dID1cclxuICAgICAgICAgICAgICAgICAgICBjc3MzRFN1cHBvcnRlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgKFwidHJhbnNsYXRlM0QoMCxcIiArIHRoaXMuX3kgKyBcInB4LDApXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICAoXCJ0cmFuc2xhdGVZKFwiICsgdGhpcy5feSArIFwicHgpXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICAoc3R5bGUudG9wID0gdGhpcy5feSArIFwicHhcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgdG91Y2hFbmFibGVkICYmIGhlYWRpbmcuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblRvdWNoU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgaGVhZGluZy5hZGRFdmVudExpc3RlbmVyKHByZXNzRXZlbnQsIHRoaXMub25QcmVzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25LZXlEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93bik7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGZvbGQgd2l0aGluIGFuIGFjY29yZGlvbidzIGNvbnRhaW5lci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRoaXMuX3kpXHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5feSA9IHBhcnNlSW50KHRoaXMuZWwuc3R5bGUudG9wKSB8fCAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeShpbnB1dCkge1xyXG4gICAgICAgIGlmICgoaW5wdXQgPSAraW5wdXQpICE9PSB0aGlzLl95KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBpbnB1dDtcclxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xyXG4gICAgICAgICAgICB0aGlzLnVzZVRyYW5zZm9ybXMgP1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbY3NzVHJhbnNmb3JtXSA9XHJcbiAgICAgICAgICAgICAgICBjc3MzRFN1cHBvcnRlZCA/XHJcbiAgICAgICAgICAgICAgICAoXCJ0cmFuc2xhdGUzRCgwLFwiICsgaW5wdXQgKyBcInB4LDApXCIpIDpcclxuICAgICAgICAgICAgICAgIChcInRyYW5zbGF0ZVkoXCIgKyBpbnB1dCArIFwicHgpXCIpIDpcclxuICAgICAgICAgICAgICAgIChzdHlsZS50b3AgPSBpbnB1dCArIFwicHhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWlnaHQgb2YgdGhlIGZvbGQncyBvdXRlcm1vc3QgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9oZWlnaHQpIHtcclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaGVhZGluZ0hlaWdodCArIHRoaXMuY29udGVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hlaWdodCA9IGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGhlaWdodChpbnB1dCkge1xyXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQgPSAraW5wdXQpICE9PSB0aGlzLl9oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBpbnB1dCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGhlaWdodCBvZiB0aGUgZm9sZCdzIGhlYWRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVhZGluZ0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkaW5nLnNjcm9sbEhlaWdodCArXHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0T2Zmc2V0ICtcclxuICAgICAgICAgICAgKHRoaXMudXNlQm9yZGVycyA/IHRoaXMuaGVhZGluZ0JvcmRlciA6IDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG90YWwgaGVpZ2h0IGNvbnN1bWVkIGJ5IHRoZSBoZWFkaW5nIGVsZW1lbnQncyBDU1MgYm9yZGVycywgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlYWRpbmdCb3JkZXIoKSB7XHJcbiAgICAgICAgbGV0IGhlYWRpbmcgPSB0aGlzLmhlYWRpbmc7XHJcbiAgICAgICAgcmV0dXJuIChoZWFkaW5nLm9mZnNldEhlaWdodCB8fCAwKSAtIChoZWFkaW5nLmNsaWVudEhlaWdodCB8fCAwKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb3RhbCBoZWlnaHQgb2YgdGhlIGZvbGQncyBjb250YWluZXIgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBlbEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQgKyAodGhpcy51c2VCb3JkZXJzID8gdGhpcy5lbEJvcmRlciA6IDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG90YWwgaGVpZ2h0IGNvbnN1bWVkIGJ5IGNvbnRhaW5lciBlbGVtZW50J3MgQ1NTIGJvcmRlcnMsIGlmIGFueS5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgZWxCb3JkZXIoKSB7XHJcbiAgICAgICAgbGV0IGVsID0gdGhpcy5lbDtcclxuICAgICAgICByZXR1cm4gKGVsLm9mZnNldEhlaWdodCB8fCAwKSAtIChlbC5jbGllbnRIZWlnaHQgfHwgMCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZm9sZCdzIGNvbnRhaW5lciBoYXMgYmVlbiByZXNpemVkIGluY29ycmVjdGx5LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHdyb25nU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkaW5nSGVpZ2h0ICsgdGhpcy5jb250ZW50LnNjcm9sbEhlaWdodCAhPT0gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XHJcbiAgICB9XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/fold.mjs\n");

/***/ }),

/***/ "./src/js/helpers.mjs":
/*!****************************!*\
  !*** ./src/js/helpers.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"css3DSupported\": () => (/* binding */ css3DSupported),\n/* harmony export */   \"cssTransform\": () => (/* binding */ cssTransform),\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"pressEvent\": () => (/* binding */ pressEvent),\n/* harmony export */   \"setToken\": () => (/* binding */ setToken),\n/* harmony export */   \"touchEnabled\": () => (/* binding */ touchEnabled),\n/* harmony export */   \"transitionEnd\": () => (/* binding */ transitionEnd),\n/* harmony export */   \"uniqueID\": () => (/* binding */ uniqueID)\n/* harmony export */ });\nconst touchEnabled = \"ontouchstart\" in document.documentElement;\r\nconst pressEvent = touchEnabled ? \"touchend\" : \"click\";\r\n\r\n\r\n/**\r\n * Name of the onTransitionEnd event supported by this browser.\r\n * @const {String} transitionEnd\r\n */\r\nconst transitionEnd = (function() {\r\n    const names = \"transitionend webkitTransitionEnd oTransitionEnd otransitionend\".split(\" \");\r\n    for (let i = 0; i < 4; ++i)\r\n        if (\"on\" + names[i].toLowerCase() in window)\r\n            return names[i];\r\n    return names[0];\r\n}());\r\n\r\n\r\n\r\n/**\r\n * Conditionally add or remove a token from a token-list.\r\n *\r\n * @param {DOMTokenList} list\r\n * @param {String} token\r\n * @param {Boolean} enabled\r\n */\r\nfunction setToken(list, token, enabled) {\r\n    enabled ? list.add(token) : list.remove(token);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Stop a function from firing too quickly.\r\n *\r\n * Returns a copy of the original function that runs only after the designated\r\n * number of milliseconds have elapsed. Useful for throttling onResize handlers.\r\n *\r\n * @param {Function} fn - Function to debounce\r\n * @param {Number} [limit=0] - Threshold to stall execution by, in milliseconds.\r\n * @param {Boolean} [asap=false] - Call function *before* threshold elapses, not after.\r\n * @return {Function}\r\n */\r\nfunction debounce(fn, limit = 0, asap = false) {\r\n    let started, context, args, timing;\r\n\r\n    const delayed = function() {\r\n        const timeSince = Date.now() - started;\r\n        if (timeSince >= limit) {\r\n            if (!asap) fn.apply(context, args);\r\n            if (timing) clearTimeout(timing);\r\n            timing = context = args = null;\r\n        } else timing = setTimeout(delayed, limit - timeSince);\r\n    };\r\n\r\n    // Debounced copy of original function\r\n    return function() {\r\n        context = this,\r\n            args = arguments;\r\n        if (!limit)\r\n            return fn.apply(context, args);\r\n        started = Date.now();\r\n        if (!timing) {\r\n            if (asap) fn.apply(context, args);\r\n            timing = setTimeout(delayed, limit);\r\n        }\r\n    };\r\n}\r\n\r\n\r\n\r\nconst uniqueID = (function() {\r\n    const IDs = {};\r\n    const indexes = {};\r\n\r\n\r\n    /**\r\n     * Generate a unique ID for a DOM element.\r\n     *\r\n     * By default, minimalist IDs like \"_1\" or \"_2\" are generated using internally\r\n     * tracked incrementation. Uglier, more collision-proof IDs can be generated by\r\n     * passing a truthy value to the function's first argument.\r\n     *\r\n     * Irrespective of whether values are being generated simply or randomly, the\r\n     * document tree is always consulted first to ensure a duplicate ID is never\r\n     * returned.\r\n     *\r\n     * @param {String}  prefix - Prefix prepended to result. Default: \"_\"\r\n     * @param {Boolean} random - Generate collision-proof IDs using random symbols\r\n     * @param {Number}  length - Length of random passwords. Default: 6\r\n     * @return {String}\r\n     */\r\n    function uniqueID(prefix, complex, length) {\r\n        length = +(length || 6);\r\n        let result = (prefix = prefix || \"_\");\r\n\r\n        // Simple IDs\r\n        if (!complex) {\r\n\r\n            // Set this prefix's starting index if it's not been used yet\r\n            if (!indexes[prefix])\r\n                indexes[prefix] = 0;\r\n\r\n            result += ++indexes[prefix];\r\n        }\r\n\r\n        // Uglier, more collision-proof IDs\r\n        else {\r\n            const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n            result += chars[Math.round(Math.random() * 51)];\r\n            while (result.length < length)\r\n                result += chars[Math.round(Math.random() * 61)];\r\n        }\r\n\r\n        return IDs[result] || document.getElementById(result) ?\r\n            uniqueID(prefix, complex) :\r\n            (IDs[result] = true, result);\r\n    }\r\n\r\n\r\n    return uniqueID;\r\n}());\r\n\r\n\r\n\r\n// Name of the CSSOM property used by this browser for CSS transforms\r\nconst cssTransform = (function(n) {\r\n    s = document.documentElement.style;\r\n    if ((prop = n.toLowerCase()) in s) return prop;\r\n    for (var prop, s, p = \"Webkit Moz Ms O Khtml\", p = (p.toLowerCase() + p).split(\" \"), i = 0; i < 10; ++i)\r\n        if ((prop = p[i] + n) in s) return prop;\r\n    return \"\";\r\n}(\"Transform\"));\r\n\r\n\r\n// Whether 3D transforms are supported by this browser\r\nconst css3DSupported = (function(propName) {\r\n    const e = document.createElement(\"div\"),\r\n        s = e.style;\r\n    const v = [\r\n        [\"translateY(\", \")\"],\r\n        [\"translate3d(0,\", \",0)\"]\r\n    ];\r\n    try { s[propName] = v[1].join(\"1px\"); } catch (e) {}\r\n    return v[+!!s[propName]] === v[1];\r\n}(cssTransform));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvaGVscGVycy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdHQUFnRyxRQUFRO0FBQ3hHO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ2VvdG9vbGtpdC9nZW90b29sa2l0Ly4vc3JjL2pzL2hlbHBlcnMubWpzPzNlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHRvdWNoRW5hYmxlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5leHBvcnQgY29uc3QgcHJlc3NFdmVudCA9IHRvdWNoRW5hYmxlZCA/IFwidG91Y2hlbmRcIiA6IFwiY2xpY2tcIjtcclxuXHJcblxyXG4vKipcclxuICogTmFtZSBvZiB0aGUgb25UcmFuc2l0aW9uRW5kIGV2ZW50IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXHJcbiAqIEBjb25zdCB7U3RyaW5nfSB0cmFuc2l0aW9uRW5kXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJhbnNpdGlvbkVuZCA9IChmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IG5hbWVzID0gXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmRcIi5zcGxpdChcIiBcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSlcclxuICAgICAgICBpZiAoXCJvblwiICsgbmFtZXNbaV0udG9Mb3dlckNhc2UoKSBpbiB3aW5kb3cpXHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lc1tpXTtcclxuICAgIHJldHVybiBuYW1lc1swXTtcclxufSgpKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbmRpdGlvbmFsbHkgYWRkIG9yIHJlbW92ZSBhIHRva2VuIGZyb20gYSB0b2tlbi1saXN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVRva2VuTGlzdH0gbGlzdFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5cclxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0VG9rZW4obGlzdCwgdG9rZW4sIGVuYWJsZWQpIHtcclxuICAgIGVuYWJsZWQgPyBsaXN0LmFkZCh0b2tlbikgOiBsaXN0LnJlbW92ZSh0b2tlbik7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFN0b3AgYSBmdW5jdGlvbiBmcm9tIGZpcmluZyB0b28gcXVpY2tseS5cclxuICpcclxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHRoYXQgcnVucyBvbmx5IGFmdGVyIHRoZSBkZXNpZ25hdGVkXHJcbiAqIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLiBVc2VmdWwgZm9yIHRocm90dGxpbmcgb25SZXNpemUgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gRnVuY3Rpb24gdG8gZGVib3VuY2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdD0wXSAtIFRocmVzaG9sZCB0byBzdGFsbCBleGVjdXRpb24gYnksIGluIG1pbGxpc2Vjb25kcy5cclxuICogQHBhcmFtIHtCb29sZWFufSBbYXNhcD1mYWxzZV0gLSBDYWxsIGZ1bmN0aW9uICpiZWZvcmUqIHRocmVzaG9sZCBlbGFwc2VzLCBub3QgYWZ0ZXIuXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZuLCBsaW1pdCA9IDAsIGFzYXAgPSBmYWxzZSkge1xyXG4gICAgbGV0IHN0YXJ0ZWQsIGNvbnRleHQsIGFyZ3MsIHRpbWluZztcclxuXHJcbiAgICBjb25zdCBkZWxheWVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc3QgdGltZVNpbmNlID0gRGF0ZS5ub3coKSAtIHN0YXJ0ZWQ7XHJcbiAgICAgICAgaWYgKHRpbWVTaW5jZSA+PSBsaW1pdCkge1xyXG4gICAgICAgICAgICBpZiAoIWFzYXApIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAodGltaW5nKSBjbGVhclRpbWVvdXQodGltaW5nKTtcclxuICAgICAgICAgICAgdGltaW5nID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB0aW1pbmcgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIGxpbWl0IC0gdGltZVNpbmNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRGVib3VuY2VkIGNvcHkgb2Ygb3JpZ2luYWwgZnVuY3Rpb25cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjb250ZXh0ID0gdGhpcyxcclxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBpZiAoIWxpbWl0KVxyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKCF0aW1pbmcpIHtcclxuICAgICAgICAgICAgaWYgKGFzYXApIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB0aW1pbmcgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIGxpbWl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCB1bmlxdWVJRCA9IChmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IElEcyA9IHt9O1xyXG4gICAgY29uc3QgaW5kZXhlcyA9IHt9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBhIERPTSBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIG1pbmltYWxpc3QgSURzIGxpa2UgXCJfMVwiIG9yIFwiXzJcIiBhcmUgZ2VuZXJhdGVkIHVzaW5nIGludGVybmFsbHlcclxuICAgICAqIHRyYWNrZWQgaW5jcmVtZW50YXRpb24uIFVnbGllciwgbW9yZSBjb2xsaXNpb24tcHJvb2YgSURzIGNhbiBiZSBnZW5lcmF0ZWQgYnlcclxuICAgICAqIHBhc3NpbmcgYSB0cnV0aHkgdmFsdWUgdG8gdGhlIGZ1bmN0aW9uJ3MgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSXJyZXNwZWN0aXZlIG9mIHdoZXRoZXIgdmFsdWVzIGFyZSBiZWluZyBnZW5lcmF0ZWQgc2ltcGx5IG9yIHJhbmRvbWx5LCB0aGVcclxuICAgICAqIGRvY3VtZW50IHRyZWUgaXMgYWx3YXlzIGNvbnN1bHRlZCBmaXJzdCB0byBlbnN1cmUgYSBkdXBsaWNhdGUgSUQgaXMgbmV2ZXJcclxuICAgICAqIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgcHJlZml4IC0gUHJlZml4IHByZXBlbmRlZCB0byByZXN1bHQuIERlZmF1bHQ6IFwiX1wiXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmRvbSAtIEdlbmVyYXRlIGNvbGxpc2lvbi1wcm9vZiBJRHMgdXNpbmcgcmFuZG9tIHN5bWJvbHNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgbGVuZ3RoIC0gTGVuZ3RoIG9mIHJhbmRvbSBwYXNzd29yZHMuIERlZmF1bHQ6IDZcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5pcXVlSUQocHJlZml4LCBjb21wbGV4LCBsZW5ndGgpIHtcclxuICAgICAgICBsZW5ndGggPSArKGxlbmd0aCB8fCA2KTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gKHByZWZpeCA9IHByZWZpeCB8fCBcIl9cIik7XHJcblxyXG4gICAgICAgIC8vIFNpbXBsZSBJRHNcclxuICAgICAgICBpZiAoIWNvbXBsZXgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHByZWZpeCdzIHN0YXJ0aW5nIGluZGV4IGlmIGl0J3Mgbm90IGJlZW4gdXNlZCB5ZXRcclxuICAgICAgICAgICAgaWYgKCFpbmRleGVzW3ByZWZpeF0pXHJcbiAgICAgICAgICAgICAgICBpbmRleGVzW3ByZWZpeF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICsraW5kZXhlc1twcmVmaXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVWdsaWVyLCBtb3JlIGNvbGxpc2lvbi1wcm9vZiBJRHNcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyc1tNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiA1MSldO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyc1tNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiA2MSldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIElEc1tyZXN1bHRdIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlc3VsdCkgP1xyXG4gICAgICAgICAgICB1bmlxdWVJRChwcmVmaXgsIGNvbXBsZXgpIDpcclxuICAgICAgICAgICAgKElEc1tyZXN1bHRdID0gdHJ1ZSwgcmVzdWx0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHVuaXF1ZUlEO1xyXG59KCkpO1xyXG5cclxuXHJcblxyXG4vLyBOYW1lIG9mIHRoZSBDU1NPTSBwcm9wZXJ0eSB1c2VkIGJ5IHRoaXMgYnJvd3NlciBmb3IgQ1NTIHRyYW5zZm9ybXNcclxuZXhwb3J0IGNvbnN0IGNzc1RyYW5zZm9ybSA9IChmdW5jdGlvbihuKSB7XHJcbiAgICBzID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG4gICAgaWYgKChwcm9wID0gbi50b0xvd2VyQ2FzZSgpKSBpbiBzKSByZXR1cm4gcHJvcDtcclxuICAgIGZvciAodmFyIHByb3AsIHMsIHAgPSBcIldlYmtpdCBNb3ogTXMgTyBLaHRtbFwiLCBwID0gKHAudG9Mb3dlckNhc2UoKSArIHApLnNwbGl0KFwiIFwiKSwgaSA9IDA7IGkgPCAxMDsgKytpKVxyXG4gICAgICAgIGlmICgocHJvcCA9IHBbaV0gKyBuKSBpbiBzKSByZXR1cm4gcHJvcDtcclxuICAgIHJldHVybiBcIlwiO1xyXG59KFwiVHJhbnNmb3JtXCIpKTtcclxuXHJcblxyXG4vLyBXaGV0aGVyIDNEIHRyYW5zZm9ybXMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcclxuZXhwb3J0IGNvbnN0IGNzczNEU3VwcG9ydGVkID0gKGZ1bmN0aW9uKHByb3BOYW1lKSB7XHJcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcclxuICAgICAgICBzID0gZS5zdHlsZTtcclxuICAgIGNvbnN0IHYgPSBbXHJcbiAgICAgICAgW1widHJhbnNsYXRlWShcIiwgXCIpXCJdLFxyXG4gICAgICAgIFtcInRyYW5zbGF0ZTNkKDAsXCIsIFwiLDApXCJdXHJcbiAgICBdO1xyXG4gICAgdHJ5IHsgc1twcm9wTmFtZV0gPSB2WzFdLmpvaW4oXCIxcHhcIik7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICByZXR1cm4gdlsrISFzW3Byb3BOYW1lXV0gPT09IHZbMV07XHJcbn0oY3NzVHJhbnNmb3JtKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/helpers.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;